########################################################################
# Simulate a Matern field
########################################################################

book.rMatern <- function(n, coords, sigma=1, range, kappa = sqrt(8*nu)/range, variance = sigma^2, nu=1) {
  m <- as.matrix(dist(coords))
  m <- exp((1-nu)*log(2) + nu*log(kappa*m)-
             lgamma(nu))*besselK(m*kappa, nu)
  diag(m) <- 1
  return(drop(crossprod(chol(variance*m),
                        matrix(rnorm(nrow(coords)*n), ncol=n))))
}

########################################################################
# Simulate data
########################################################################

Sim_Data_Ortho_error_v3 <- function(true.vals){
  
  ## Load the shapefile
  areas = st_read(system.file("etc/shapes/bhicv.shp",
                              package="spdep")[1])
  ## Build the mesh:
  mesh <- inla.mesh.2d(boundary=areas,
                       max.edge=c(0.075, 0.5),
                       min.angle=c(30, 21),
                       max.n=c(48000, 16000), 
                       max.n.strict=c(128000, 128000), 
                       cutoff=0.022, 
                       offset=c(0.17, 0.685)) 
  
  ## Simulation grid
  load(file="px2.Rdata")
  px <- st_as_sf(px)
  locs = st_coordinates(px)

  ## Simulate the spatial field 
  nu = 1
  kappa = sqrt(8*nu)/true.vals$stage_1$rho 
  omega = book.rMatern(n = 1, 
                       coords = locs, 
                       sigma = 1, 
                       range = true.vals$stage_1$rho, 
                       kappa = kappa, 
                       variance = true.vals$stage_1$sigma_omega^2, 
                       nu = nu)
  px$omega = as.matrix(omega)
  
  ## Simulate the covariate field z(s)
  set.seed(4321)
  cov.field = book.rMatern(n = 1, 
                           coords = locs, 
                           sigma = 1, 
                           range = 3, 
                           kappa = sqrt(8)/3, 
                           variance = 3, 
                           nu = nu)
  cov.field <- data.frame(as.matrix(cov.field))
  colnames(cov.field) <- "z"
  px$z = (cov.field$z - min(cov.field$z))

  ## Simulate the latent field of interest x(s)
  px$xvar = true.vals$stage_1$beta0 + (true.vals$stage_1$beta1 * px$z) + (px$omega)
  
  
  ## Simulate error field
  set.seed(Sys.time())
  kappa = sqrt(8*nu)/true.vals$stage_1$rho.error 
  error.field = book.rMatern(n = 1, 
                             coords = locs, 
                             sigma = 1, 
                             range = true.vals$stage_1$rho.error, 
                             kappa = kappa, 
                             variance = true.vals$stage_1$sigma_error^2, 
                             nu = nu)
  error.field = as.vector(error.field)
  px$error = error.field
  
  ## Simulated observed values at the numerical models or satellite data (to be sampled to coarser resolution)
  px$satellite = (true.vals$stage_1$alpha1 * px$xvar) + px$error + rnorm(length(px$xvar), mean = 0, sd = 0.01)
  
  ## Simulated "observed" values at stations (this will be randomly sampled later)
  px$w = px$xvar + rnorm(length(px$xvar), mean = 0, sd = true.vals$stage_1$sigma_e)
  
  ## Create the coarse data for the numerical model or satellite data
  new_px_data <- px[seq(1, nrow(px), 2),]
  coords.y <- unique(st_coordinates(new_px_data)[,2])
  coords.y <- data.frame(coords.y = coords.y,
                         ind = 1:length(coords.y))
  new_px_data$coords.y <- st_coordinates(new_px_data)[,2]
  new_px_data <- left_join(new_px_data,
                           coords.y,
                           by = "coords.y")
  new_px_data <- new_px_data[-which(new_px_data$ind %in% seq(2,66,by=2)),]
  
  ## Simulated the observed values at stations 
  monitors_data <- parallel::mclapply(seq(n_monitors_vec), function(x){
    set.seed(1)
    sample_points <- spsample(as(areas,"Spatial"),
                              n = n_monitors_vec[x],
                              type = "random")
    sample_points <- st_as_sf(sample_points)
  }, mc.set.seed = TRUE, mc.cores = ncores)
  for(i in 1:length(n_monitors_vec)){
    monitors_data[[i]] <- px[st_nearest_feature(monitors_data[[i]], px),]
  }
  
  return(out = list(px = px,
                    monitors_data = monitors_data,
                    numerical_models_data = new_px_data,
                    areas = areas,
                    mesh = mesh))
}




########################################################################
# Fit the stations-only model
########################################################################

Fit_Mons_only_v3 <- function(data = sim_data,
                             max_iter = max_iter,
                             tolerance = tolerance,
                             matching_priors = TRUE){
  
  monitors_data <- data$monitors_data
  areas <- data$areas
  px <- data$px

  # Build mesh for model fitting
  boundary <- st_union(areas)
  mesh <- fm_mesh_2d(boundary=boundary,
                     max.edge=c(0.075, 0.5),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), 
                     max.n.strict=c(128000, 128000), 
                     cutoff=0.022, 
                     offset=c(0.17, 0.685))
  
  if(matching_priors == TRUE){
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(true.vals$stage_1$rho, 0.5),
                                 prior.sigma = c(true.vals$stage_1$sigma_omega, 0.5),
                                 constr = FALSE)
  }else{   
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(.5, 0.5),
                                 prior.sigma = c(1, 0.5),
                                 constr = FALSE)
  }

  # Model components 
  cmp = w ~ -1 + spde(main = geometry, model = matern) + beta_0(1) + beta_1(z, model = "linear")
  
  start = Sys.time()
  if(matching_priors == TRUE){
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(true.vals$stage_1$sigma_e, 0.5)))),
                                 bru_method=list(rel_tol = tolerance)))
  }else{
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(1.5, 0.5)))),
                                 bru_method=list(rel_tol = tolerance)))
  }
  end = Sys.time()
  
  return(out = list(fit_res = fit_res,
                    time = end - start))
  
} 


########################################################################
# Fit the regression calibration model
########################################################################

Fit_Regcalib_only_v2 <- function(data = sim_data,
                                 max_iter = max_iter,
                                 tolerance = tolerance,
                                 matching_priors = TRUE){
                          
  monitors_data <- data$monitors_data
  areas <- data$areas
  px <- data$px
  boundary <- st_union(areas)

  # Build mesh for model fitting
  mesh <- fm_mesh_2d(boundary=boundary,
                     max.edge=c(0.075, 0.5),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), 
                     max.n.strict=c(128000, 128000), 
                     cutoff=0.022, 
                     offset=c(0.17, 0.685))
                          
  # Interpolate the values of the numerical model/satellite on the location of the stations
  start = Sys.time()
  cmp = satellite ~ -1 + spde(main = geometry, model = matern) + beta_0(1) 
  matern = inla.spde2.pcmatern(mesh,
                               prior.range = c(1, 0.5),
                               prior.sigma = c(1, 0.5),
                               constr = FALSE)
  fit_interp = bru(components = cmp,
                   data = data$numerical_models_data,
                   family = "Gaussian",
                   control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(1, 0.5)))),
                   options = list(control.inla = list(int.strategy = "eb"),
                                  bru_verbose = 0,
                                  bru_max_iter = max_iter,
                                  bru_method=list(rel_tol = tolerance)))
  preds <- predict(fit_interp,
                   newdata = monitors_data ,
                   formula =~ spde + beta_0)
  monitors_data$pred_satellite <- preds$mean
  
  if(matching_priors == TRUE){    
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(true.vals$stage_1$rho, 0.5),
                                 prior.sigma = c(true.vals$stage_1$sigma_omega, 0.5),
                                 constr = FALSE)
  }else{
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(.5, 0.5),
                                 prior.sigma = c(1, 0.5),
                                 constr = FALSE)
  }

  # Model components
  cmp = w ~ -1 + spde(main = geometry, model = matern) + beta_0(1) + beta_1(z, model = "linear") +
    beta_2(pred_satellite, model = "linear")
 
  if(matching_priors == TRUE){
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(true.vals$stage_1$sigma_e, 0.5)))),
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 bru_method=list(rel_tol = tolerance)))
  }else{
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(1.5, 0.5)))),
                                 bru_method=list(rel_tol = tolerance)))
  }
  end = Sys.time()
  
  return(out = list(fit_res = fit_res,
                    fit_interp = fit_interp,
                    time = end - start))
  
} 



########################################################################
# Fit the proposed data fusion model
########################################################################

Fit_Ortho_Error_v5 <- function(data = sim_data_2,
                               max_iter = max_iter,
                               tolerance = tolerance,
                               matching_priors = TRUE,
                               a = a){
  
  monitors_data <- data$monitors_data
  areas <- data$areas
  px <- data$px

  # Build mesh for model fitting
  boundary <- st_union(areas)
  mesh <- fm_mesh_2d(boundary=boundary,
                     max.edge=c(0.075, 0.5),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), ## Safeguard against large meshes.
                     max.n.strict=c(128000, 128000), ## Don't build a huge mesh!
                     cutoff=0.022, ## Filter away adjacent points.
                     offset=c(0.17, 0.685))
  proxydata <- data$numerical_models_data
  
  if(matching_priors == TRUE){
    # SPDE spatial field model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(true.vals$stage_1$rho, 0.5),
                                 prior.sigma = c(true.vals$stage_1$sigma_omega, 0.5),
                                 constr = FALSE)
    # Error field model
    matern_error = inla.spde2.pcmatern(mesh,
                                       prior.range = c(true.vals$stage_1$rho.error, 0.5),
                                       prior.sigma = c(true.vals$stage_1$sigma_error, 0.5),
                                       constr = FALSE)    
  }else{
    # SPDE spatial field model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(.5, 0.5),
                                 prior.sigma = c(1, 0.5),
                                 constr = FALSE)    
    # Error field model
    matern_error = inla.spde2.pcmatern(mesh,
                                       prior.range = c(.5, 0.5),
                                       prior.sigma = c(.5, 0.5),
                                       constr = FALSE)
    
  }
  
  # Model components
  cmp = ~ -1 + beta_0(1) + beta_1(z, model = "linear") + 
    spde(main = geometry, model = matern) +
    matern_error(main = geometry, model = matern_error)
  
  # Model for the stations (w_1(s))
  expo_fml = w ~ beta_0 + beta_1 + spde 
  if(matching_priors == TRUE){
    expo_lik = like("Gaussian",
                    formula = expo_fml,
                    include = c("beta_0", "beta_1", "spde"),
                    data = monitors_data,
                    control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                   param = c(true.vals$stage_1$sigma_e, 0.5)))))
  }else{
    expo_lik = like("Gaussian",
                    formula = expo_fml,
                    include = c("beta_0", "beta_1", "spde"),
                    data = monitors_data,
                    control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                   param = c(1.5, 0.5)))))
  }
  
  
  # Model for the numerical model/satellite data
  if(matching_priors == TRUE){
    fml = paste0("satellite ~ ",a, " * (beta_0 + beta_1 + spde) + matern_error")
    proxy_fml = as.formula(fml)
    proxy_lik = like("Gaussian",
                     formula = proxy_fml,
                     include = c("beta_0", "beta_1","spde", "matern_error"),
                     include_latent = TRUE,
                     data = proxydata,
                     control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                    param = c(0.01, 0.5)))))
  }else{
    fml = paste0("satellite ~ ",a, " * (beta_0 + beta_1 + spde) + matern_error")
    proxy_fml = as.formula(fml)
    proxy_lik = like("Gaussian",
                     formula = proxy_fml,
                     include = c("beta_0", "beta_1","spde", "matern_error"),
                     include_latent = TRUE,
                     data = proxydata,
                     control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                    param = c(0.05, 0.5)))))
  }
  
  start = Sys.time()
  fit_res <- bru(cmp, expo_lik, proxy_lik,
                 options = list(control.inla = list(int.strategy = "eb"),
                                bru_verbose = 0,
                                bru_max_iter = max_iter,
                                bru_method=list(rel_tol = tolerance)))
  end = Sys.time()
  
  return(out = list(fit_res = fit_res,
                    time = end - start))
  
}




########################################################################
# Compute posterior prediction scores for stations-only model
########################################################################

compute_I_x_v3 <- function(model = model,
                           data = px,
                           stations = stations){
  
  # Compute predictions of x(s) on the grid
  preds <- predict(model,
                   newdata = data,
                   formula = ~ beta_0 + beta_1 + spde)
  data$pred.x = preds$mean
  data$sq.diff = (data$xvar - data$pred.x)^2
  data$absP.error = abs((data$xvar - data$pred.x)/data$xvar)
  data$pred.SD = preds$sd
  preds_f <- preds

  # Compute predictions for the stations data w_1(s)
  preds <- predict(model,
                   newdata = stations,
                   formula = ~ beta_0 + beta_1 + spde)
  stations$pred <- preds$mean
  # Sample values of the measurement error variance
  samples <- 1/inla.rmarginal(200,model$marginals.hyperpar$`Precision for the Gaussian observations`)
  post_mean <- mean(samples)
  post_var <- var(samples)
  # Compute Dawid-Sebastiani score
  stations$DS_score <- (stations$xvar - stations$pred)^2 / (post_mean + preds$sd^2) + log(post_mean + preds$sd^2)
  
  return(out = list(I_x = mean(data$sq.diff), # average squared-error for x(s) estimates
                    I_x_v2 = mean(stations$DS_score), # average DS score
                    P_x = mean(data$absP.error), # average relative error for x(s)
                    ave_sd = mean(data$pred.SD), # average posterior uncertainty
                    pred.x = data$pred.x,
                    pred.SD = data$pred.SD,
                    sq.diff.vec = data$sq.diff,
                    absP.error.vec = data$absP.error,
                    Cor = cor(data$xvar, preds_f$mean),
                    true.x = data$xvar))
  
}



########################################################################
# Compute posterior prediction scores for regression calibration model
########################################################################

compute_I_x_regcalib <- function(model = model,
                                 data = px,
                                 stations = stations){

  # Interpolate/predict the values of the numerical model/satellite on the prediction grid                      
  preds_satellite <- predict(model$fit_interp,
                             newdata = data,
                             formula =~ beta_0 + spde)
  data$pred_satellite <- preds_satellite$mean

  # Compute predictions of x(s) on the grid
  preds <- predict(model$fit_res,
                   newdata = data,
                   formula = ~ beta_0 + beta_1 + beta_2 + spde)
  data$pred.x = preds$mean
  data$sq.diff = (data$xvar - data$pred.x)^2
  data$absP.error = abs((data$xvar - data$pred.x)/data$xvar)
  data$pred.SD = preds$sd
  preds_f <- preds

  # Interpolate/predict the values of the numerical model/satellite on the location of the stations      
  preds_satellite <- predict(model$fit_interp,
                             newdata = stations,
                             formula =~ beta_0 + spde)
  stations$pred_satellite <- preds_satellite$mean

  # Compute predictions for the stations data w_1(s)
  preds <- predict(model$fit_res,
                   newdata = stations,
                   formula = ~ beta_0 + beta_1 + beta_2 + spde)
  stations$pred <- preds$mean
  # Sample values of the measurement error variance
  samples <- 1/inla.rmarginal(200,model$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`)
  post_mean <- mean(samples)
  post_var <- var(samples)
  # Compute Dawid-Sebastiani score
  stations$DS_score <- (stations$xvar - stations$pred)^2 / (post_mean + preds$sd^2) + log(post_mean + preds$sd^2)
  
  
  return(out = list(I_x = mean(data$sq.diff), # average squared-error for x(s) estimates
                    I_x_v2 = mean(stations$DS_score), # average DS score
                    P_x = mean(data$absP.error), # average relative error for x(s)
                    ave_sd = mean(data$pred.SD), # average posterior uncertainty
                    pred.x = data$pred.x,
                    pred.SD = data$pred.SD,
                    sq.diff.vec = data$sq.diff,
                    absP.error.vec = data$absP.error,
                    Cor = cor(data$xvar, preds_f$mean),
                    true.x = data$xvar))

}



########################################################################
# Compute posterior prediction scores for proposed model
########################################################################

compute_I_x_datafus <- function(model_list = res_sim_data_1,
                                weights = bma.w.method_data1,
                                data = sim_data_1$px,
                                stations = sim_data_1$monitors_data,
                                ind_model = index_model){

  # Compute the predictions of x(s) for each conditional INLA model (conditional an \alpha_1)
  preds_list <- lapply(1:6, function(i){
    predict(model_list[[i]]$fit_res,
            newdata = data,
            formula = ~ beta_0 + beta_1 + spde)
  })
  preds_mean <- lapply(1:6, function(i){
    preds_list[[i]]$mean
  })
  # Compute the model-averaged predictions of x(s)
  preds_mean <- matrix(unlist(preds_mean), ncol = 6, byrow = FALSE)
  preds_mean_BMA <- preds_mean[,1]*weights[1] + preds_mean[,2]*weights[2] + preds_mean[,3]*weights[3] +
    preds_mean[,4]*weights[4] + preds_mean[,5]*weights[5] + preds_mean[,6]*weights[6]

  # Compute the SD of the model-averaged predictions
  preds_sd <- lapply(1:6, function(i){
    preds_list[[i]]$sd
  })
  preds_sd <- matrix(unlist(preds_sd), ncol = 6, byrow = FALSE)
  preds_sd_BMA <- sqrt((preds_sd[,1]^2*weights[1]^2) + (preds_sd[,2]^2*weights[2]^2) + (preds_sd[,3]^2*weights[3]^2) +
                         (preds_sd[,4]^2*weights[4]^2) + (preds_sd[,5]^2*weights[5]^2) + (preds_sd[,6]^2*weights[6]^2))
  
  data$pred.x = preds_mean_BMA
  data$sq.diff = (data$xvar - data$pred.x)^2 # squared error
  data$absP.error = abs((data$xvar - data$pred.x)/data$xvar) # relative error
  data$pred.SD = preds_sd_BMA # posterior uncertainty
  
  # Compute the DS score on the stations data using the model with the highest weight
  samples <- 1/inla.rmarginal(200,model_list[[ind_model]]$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`)
  post_mean <- mean(samples)
  post_var <- var(samples)
  preds <- predict(model_list[[ind_model]]$fit_res,
                   newdata = stations,
                   formula = ~ beta_0 + beta_1 + spde)
  stations$DS_score <- (stations$xvar - preds$mean)^2 / (post_mean + preds$sd^2) + log(post_mean + preds$sd^2)
  
  
  return(out = list(I_x = mean(data$sq.diff), # average squared-error for x(s) estimates
                    I_x_v2 = mean(stations$DS_score), # average DS score
                    P_x = mean(data$absP.error), # average relative error for x(s)
                    ave_sd = mean(data$pred.SD), # average posterior uncertainty
                    pred.x = data$pred.x,
                    pred.SD = data$pred.SD,
                    sq.diff.vec = data$sq.diff,
                    absP.error.vec = data$absP.error,
                    Cor = cor(data$xvar, preds_mean_BMA),
                    true.x = data$xvar))

}



