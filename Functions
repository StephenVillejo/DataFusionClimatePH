########################################################################
# Simulate a Matern field
########################################################################

book.rMatern <- function(n, coords, sigma=1, range, kappa = sqrt(8*nu)/range, variance = sigma^2, nu=1) {
  m <- as.matrix(dist(coords))
  m <- exp((1-nu)*log(2) + nu*log(kappa*m)-
             lgamma(nu))*besselK(m*kappa, nu)
  diag(m) <- 1
  return(drop(crossprod(chol(variance*m),
                        matrix(rnorm(nrow(coords)*n), ncol=n))))
}

########################################################################
# Simulate data
########################################################################

Sim_Data_Ortho_error_v3 <- function(true.vals){
  
  ## Load the shapefile
  areas = st_read(system.file("etc/shapes/bhicv.shp",
                              package="spdep")[1])
  ## Build the mesh:
  mesh <- inla.mesh.2d(boundary=areas,
                       max.edge=c(0.075, 0.5),
                       min.angle=c(30, 21),
                       max.n=c(48000, 16000), 
                       max.n.strict=c(128000, 128000), 
                       cutoff=0.022, 
                       offset=c(0.17, 0.685)) 
  
  ## Simulation grid
  load(file="px2.Rdata")
  px <- st_as_sf(px)
  locs = st_coordinates(px)

  ## Simulate the spatial field 
  nu = 1
  kappa = sqrt(8*nu)/true.vals$stage_1$rho 
  omega = book.rMatern(n = 1, 
                       coords = locs, 
                       sigma = 1, 
                       range = true.vals$stage_1$rho, 
                       kappa = kappa, 
                       variance = true.vals$stage_1$sigma_omega^2, 
                       nu = nu)
  px$omega = as.matrix(omega)
  
  ## Simulate the covariate field z(s)
  set.seed(4321)
  cov.field = book.rMatern(n = 1, 
                           coords = locs, 
                           sigma = 1, 
                           range = 3, 
                           kappa = sqrt(8)/3, 
                           variance = 3, 
                           nu = nu)
  cov.field <- data.frame(as.matrix(cov.field))
  colnames(cov.field) <- "z"
  px$z = (cov.field$z - min(cov.field$z))

  ## Simulate the latent field of interest x(s)
  px$xvar = true.vals$stage_1$beta0 + (true.vals$stage_1$beta1 * px$z) + (px$omega)
  
  
  ## Simulate error field
  set.seed(Sys.time())
  kappa = sqrt(8*nu)/true.vals$stage_1$rho.error 
  error.field = book.rMatern(n = 1, 
                             coords = locs, 
                             sigma = 1, 
                             range = true.vals$stage_1$rho.error, 
                             kappa = kappa, 
                             variance = true.vals$stage_1$sigma_error^2, 
                             nu = nu)
  error.field = as.vector(error.field)
  px$error = error.field
  
  ## Simulated observed values at the numerical models or satellite data (to be sampled to coarser resolution)
  px$satellite = (true.vals$stage_1$alpha1 * px$xvar) + px$error + rnorm(length(px$xvar), mean = 0, sd = 0.01)
  
  ## Simulated "observed" values at stations (this will be randomly sampled later)
  px$w = px$xvar + rnorm(length(px$xvar), mean = 0, sd = true.vals$stage_1$sigma_e)
  
  ## Create the coarse data for the numerical model or satellite data
  new_px_data <- px[seq(1, nrow(px), 2),]
  coords.y <- unique(st_coordinates(new_px_data)[,2])
  coords.y <- data.frame(coords.y = coords.y,
                         ind = 1:length(coords.y))
  new_px_data$coords.y <- st_coordinates(new_px_data)[,2]
  new_px_data <- left_join(new_px_data,
                           coords.y,
                           by = "coords.y")
  new_px_data <- new_px_data[-which(new_px_data$ind %in% seq(2,66,by=2)),]
  
  ## Simulated the observed values at stations 
  monitors_data <- parallel::mclapply(seq(n_monitors_vec), function(x){
    set.seed(1)
    sample_points <- spsample(as(areas,"Spatial"),
                              n = n_monitors_vec[x],
                              type = "random")
    sample_points <- st_as_sf(sample_points)
  }, mc.set.seed = TRUE, mc.cores = ncores)
  for(i in 1:length(n_monitors_vec)){
    monitors_data[[i]] <- px[st_nearest_feature(monitors_data[[i]], px),]
  }
  
  return(out = list(px = px,
                    monitors_data = monitors_data,
                    numerical_models_data = new_px_data,
                    areas = areas,
                    mesh = mesh))
}




########################################################################
# Fit the stations-only model
########################################################################

Fit_Mons_only_v3 <- function(data = sim_data,
                             max_iter = max_iter,
                             tolerance = tolerance,
                             matching_priors = TRUE){
  
  monitors_data <- data$monitors_data
  areas <- data$areas
  px <- data$px

  # Build mesh for model fitting
  boundary <- st_union(areas)
  mesh <- fm_mesh_2d(boundary=boundary,
                     max.edge=c(0.075, 0.5),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), 
                     max.n.strict=c(128000, 128000), 
                     cutoff=0.022, 
                     offset=c(0.17, 0.685))
  
  if(matching_priors == TRUE){
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(true.vals$stage_1$rho, 0.5),
                                 prior.sigma = c(true.vals$stage_1$sigma_omega, 0.5),
                                 constr = FALSE)
  }else{   
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(.5, 0.5),
                                 prior.sigma = c(1, 0.5),
                                 constr = FALSE)
  }

  # Model components 
  cmp = w ~ -1 + spde(main = geometry, model = matern) + beta_0(1) + beta_1(z, model = "linear")
  
  start = Sys.time()
  if(matching_priors == TRUE){
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(true.vals$stage_1$sigma_e, 0.5)))),
                                 bru_method=list(rel_tol = tolerance)))
  }else{
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(1.5, 0.5)))),
                                 bru_method=list(rel_tol = tolerance)))
  }
  end = Sys.time()
  
  return(out = list(fit_res = fit_res,
                    time = end - start))
  
} 


########################################################################
# Fit the regression calibration model
########################################################################

Fit_Regcalib_only_v2 <- function(data = sim_data,
                                 max_iter = max_iter,
                                 tolerance = tolerance,
                                 matching_priors = TRUE){
                          
  monitors_data <- data$monitors_data
  areas <- data$areas
  px <- data$px
  boundary <- st_union(areas)

  # Build mesh for model fitting
  mesh <- fm_mesh_2d(boundary=boundary,
                     max.edge=c(0.075, 0.5),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), 
                     max.n.strict=c(128000, 128000), 
                     cutoff=0.022, 
                     offset=c(0.17, 0.685))
                          
  # Interpolate the values of the numerical model/satellite on the location of the stations
  start = Sys.time()
  cmp = satellite ~ -1 + spde(main = geometry, model = matern) + beta_0(1) 
  matern = inla.spde2.pcmatern(mesh,
                               prior.range = c(1, 0.5),
                               prior.sigma = c(1, 0.5),
                               constr = FALSE)
  fit_interp = bru(components = cmp,
                   data = data$numerical_models_data,
                   family = "Gaussian",
                   control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(1, 0.5)))),
                   options = list(control.inla = list(int.strategy = "eb"),
                                  bru_verbose = 0,
                                  bru_max_iter = max_iter,
                                  bru_method=list(rel_tol = tolerance)))
  preds <- predict(fit_interp,
                   newdata = monitors_data ,
                   formula =~ spde + beta_0)
  monitors_data$pred_satellite <- preds$mean
  
  if(matching_priors == TRUE){    
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(true.vals$stage_1$rho, 0.5),
                                 prior.sigma = c(true.vals$stage_1$sigma_omega, 0.5),
                                 constr = FALSE)
  }else{
    # SPDE model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(.5, 0.5),
                                 prior.sigma = c(1, 0.5),
                                 constr = FALSE)
  }

  # Model components
  cmp = w ~ -1 + spde(main = geometry, model = matern) + beta_0(1) + beta_1(z, model = "linear") +
    beta_2(pred_satellite, model = "linear")
 
  if(matching_priors == TRUE){
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(true.vals$stage_1$sigma_e, 0.5)))),
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 bru_method=list(rel_tol = tolerance)))
  }else{
    fit_res = bru(components = cmp,
                  data = monitors_data,
                  family = "Gaussian",
                  options = list(control.inla = list(int.strategy = "eb"),
                                 bru_verbose = 0,
                                 bru_max_iter = max_iter,
                                 control.family = list(hyper = list(prec = list(prior = "pc.prec", param = c(1.5, 0.5)))),
                                 bru_method=list(rel_tol = tolerance)))
  }
  end = Sys.time()
  
  return(out = list(fit_res = fit_res,
                    fit_interp = fit_interp,
                    time = end - start))
  
} 



########################################################################
# Fit the proposed data fusion model
########################################################################

Fit_Ortho_Error_v5 <- function(data = sim_data_2,
                               max_iter = max_iter,
                               tolerance = tolerance,
                               matching_priors = TRUE,
                               a = a){
  
  monitors_data <- data$monitors_data
  areas <- data$areas
  px <- data$px

  # Build mesh for model fitting
  boundary <- st_union(areas)
  mesh <- fm_mesh_2d(boundary=boundary,
                     max.edge=c(0.075, 0.5),
                     min.angle=c(30, 21),
                     max.n=c(48000, 16000), ## Safeguard against large meshes.
                     max.n.strict=c(128000, 128000), ## Don't build a huge mesh!
                     cutoff=0.022, ## Filter away adjacent points.
                     offset=c(0.17, 0.685))
  proxydata <- data$numerical_models_data
  
  if(matching_priors == TRUE){
    # SPDE spatial field model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(true.vals$stage_1$rho, 0.5),
                                 prior.sigma = c(true.vals$stage_1$sigma_omega, 0.5),
                                 constr = FALSE)
    # Error field model
    matern_error = inla.spde2.pcmatern(mesh,
                                       prior.range = c(true.vals$stage_1$rho.error, 0.5),
                                       prior.sigma = c(true.vals$stage_1$sigma_error, 0.5),
                                       constr = FALSE)    
  }else{
    # SPDE spatial field model
    matern = inla.spde2.pcmatern(mesh,
                                 prior.range = c(.5, 0.5),
                                 prior.sigma = c(1, 0.5),
                                 constr = FALSE)    
    # Error field model
    matern_error = inla.spde2.pcmatern(mesh,
                                       prior.range = c(.5, 0.5),
                                       prior.sigma = c(.5, 0.5),
                                       constr = FALSE)
    
  }
  
  # Model components
  cmp = ~ -1 + beta_0(1) + beta_1(z, model = "linear") + 
    spde(main = geometry, model = matern) +
    matern_error(main = geometry, model = matern_error)
  
  # Model for the stations (w_1(s))
  expo_fml = w ~ beta_0 + beta_1 + spde 
  if(matching_priors == TRUE){
    expo_lik = like("Gaussian",
                    formula = expo_fml,
                    include = c("beta_0", "beta_1", "spde"),
                    data = monitors_data,
                    control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                   param = c(true.vals$stage_1$sigma_e, 0.5)))))
  }else{
    expo_lik = like("Gaussian",
                    formula = expo_fml,
                    include = c("beta_0", "beta_1", "spde"),
                    data = monitors_data,
                    control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                   param = c(1.5, 0.5)))))
  }
  
  
  # Model for the numerical model/satellite data
  if(matching_priors == TRUE){
    fml = paste0("satellite ~ ",a, " * (beta_0 + beta_1 + spde) + matern_error")
    proxy_fml = as.formula(fml)
    proxy_lik = like("Gaussian",
                     formula = proxy_fml,
                     include = c("beta_0", "beta_1","spde", "matern_error"),
                     include_latent = TRUE,
                     data = proxydata,
                     control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                    param = c(0.01, 0.5)))))
  }else{
    fml = paste0("satellite ~ ",a, " * (beta_0 + beta_1 + spde) + matern_error")
    proxy_fml = as.formula(fml)
    proxy_lik = like("Gaussian",
                     formula = proxy_fml,
                     include = c("beta_0", "beta_1","spde", "matern_error"),
                     include_latent = TRUE,
                     data = proxydata,
                     control.family = list(hyper = list(prec = list(prior = "pc.prec", 
                                                                    param = c(0.05, 0.5)))))
  }
  
  start = Sys.time()
  fit_res <- bru(cmp, expo_lik, proxy_lik,
                 options = list(control.inla = list(int.strategy = "eb"),
                                bru_verbose = 0,
                                bru_max_iter = max_iter,
                                bru_method=list(rel_tol = tolerance)))
  end = Sys.time()
  
  return(out = list(fit_res = fit_res,
                    time = end - start))
  
}




########################################################################
# Compute posterior prediction scores for stations-only model
########################################################################

compute_I_x_v3 <- function(model = model,
                           data = px,
                           stations = stations){
  
  # Compute predictions of x(s) on the grid
  preds <- predict(model,
                   newdata = data,
                   formula = ~ beta_0 + beta_1 + spde)
  data$pred.x = preds$mean
  data$sq.diff = (data$xvar - data$pred.x)^2
  data$absP.error = abs((data$xvar - data$pred.x)/data$xvar)
  data$pred.SD = preds$sd
  preds_f <- preds

  # Compute predictions for the stations data w_1(s)
  preds <- predict(model,
                   newdata = stations,
                   formula = ~ beta_0 + beta_1 + spde)
  stations$pred <- preds$mean
  # Sample values of the measurement error variance
  samples <- 1/inla.rmarginal(200,model$marginals.hyperpar$`Precision for the Gaussian observations`)
  post_mean <- mean(samples)
  post_var <- var(samples)
  # Compute Dawid-Sebastiani score
  stations$DS_score <- (stations$xvar - stations$pred)^2 / (post_mean + preds$sd^2) + log(post_mean + preds$sd^2)
  
  return(out = list(I_x = mean(data$sq.diff), # average squared-error for x(s) estimates
                    I_x_v2 = mean(stations$DS_score), # average DS score
                    P_x = mean(data$absP.error), # average relative error for x(s)
                    ave_sd = mean(data$pred.SD), # average posterior uncertainty
                    pred.x = data$pred.x,
                    pred.SD = data$pred.SD,
                    sq.diff.vec = data$sq.diff,
                    absP.error.vec = data$absP.error,
                    Cor = cor(data$xvar, preds_f$mean),
                    true.x = data$xvar))
  
}



########################################################################
# Compute posterior prediction scores for regression calibration model
########################################################################

compute_I_x_regcalib <- function(model = model,
                                 data = px,
                                 stations = stations){

  # Interpolate/predict the values of the numerical model/satellite on the prediction grid                      
  preds_satellite <- predict(model$fit_interp,
                             newdata = data,
                             formula =~ beta_0 + spde)
  data$pred_satellite <- preds_satellite$mean

  # Compute predictions of x(s) on the grid
  preds <- predict(model$fit_res,
                   newdata = data,
                   formula = ~ beta_0 + beta_1 + beta_2 + spde)
  data$pred.x = preds$mean
  data$sq.diff = (data$xvar - data$pred.x)^2
  data$absP.error = abs((data$xvar - data$pred.x)/data$xvar)
  data$pred.SD = preds$sd
  preds_f <- preds

  # Interpolate/predict the values of the numerical model/satellite on the location of the stations      
  preds_satellite <- predict(model$fit_interp,
                             newdata = stations,
                             formula =~ beta_0 + spde)
  stations$pred_satellite <- preds_satellite$mean

  # Compute predictions for the stations data w_1(s)
  preds <- predict(model$fit_res,
                   newdata = stations,
                   formula = ~ beta_0 + beta_1 + beta_2 + spde)
  stations$pred <- preds$mean
  # Sample values of the measurement error variance
  samples <- 1/inla.rmarginal(200,model$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`)
  post_mean <- mean(samples)
  post_var <- var(samples)
  # Compute Dawid-Sebastiani score
  stations$DS_score <- (stations$xvar - stations$pred)^2 / (post_mean + preds$sd^2) + log(post_mean + preds$sd^2)
  
  
  return(out = list(I_x = mean(data$sq.diff), # average squared-error for x(s) estimates
                    I_x_v2 = mean(stations$DS_score), # average DS score
                    P_x = mean(data$absP.error), # average relative error for x(s)
                    ave_sd = mean(data$pred.SD), # average posterior uncertainty
                    pred.x = data$pred.x,
                    pred.SD = data$pred.SD,
                    sq.diff.vec = data$sq.diff,
                    absP.error.vec = data$absP.error,
                    Cor = cor(data$xvar, preds_f$mean),
                    true.x = data$xvar))

}



########################################################################
# Compute posterior prediction scores for proposed model
########################################################################

compute_I_x_datafus <- function(model_list = res_sim_data_1,
                                weights = bma.w.method_data1,
                                data = sim_data_1$px,
                                stations = sim_data_1$monitors_data,
                                ind_model = index_model){

  # Compute the predictions of x(s) for each conditional INLA model (conditional an \alpha_1)
  preds_list <- lapply(1:6, function(i){
    predict(model_list[[i]]$fit_res,
            newdata = data,
            formula = ~ beta_0 + beta_1 + spde)
  })
  preds_mean <- lapply(1:6, function(i){
    preds_list[[i]]$mean
  })
  # Compute the model-averaged predictions of x(s)
  preds_mean <- matrix(unlist(preds_mean), ncol = 6, byrow = FALSE)
  preds_mean_BMA <- preds_mean[,1]*weights[1] + preds_mean[,2]*weights[2] + preds_mean[,3]*weights[3] +
    preds_mean[,4]*weights[4] + preds_mean[,5]*weights[5] + preds_mean[,6]*weights[6]

  # Compute the SD of the model-averaged predictions
  preds_sd <- lapply(1:6, function(i){
    preds_list[[i]]$sd
  })
  preds_sd <- matrix(unlist(preds_sd), ncol = 6, byrow = FALSE)
  preds_sd_BMA <- sqrt((preds_sd[,1]^2*weights[1]^2) + (preds_sd[,2]^2*weights[2]^2) + (preds_sd[,3]^2*weights[3]^2) +
                         (preds_sd[,4]^2*weights[4]^2) + (preds_sd[,5]^2*weights[5]^2) + (preds_sd[,6]^2*weights[6]^2))
  
  data$pred.x = preds_mean_BMA
  data$sq.diff = (data$xvar - data$pred.x)^2 # squared error
  data$absP.error = abs((data$xvar - data$pred.x)/data$xvar) # relative error
  data$pred.SD = preds_sd_BMA # posterior uncertainty
  
  # Compute the DS score on the stations data using the model with the highest weight
  samples <- 1/inla.rmarginal(200,model_list[[ind_model]]$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`)
  post_mean <- mean(samples)
  post_var <- var(samples)
  preds <- predict(model_list[[ind_model]]$fit_res,
                   newdata = stations,
                   formula = ~ beta_0 + beta_1 + spde)
  stations$DS_score <- (stations$xvar - preds$mean)^2 / (post_mean + preds$sd^2) + log(post_mean + preds$sd^2)
  
  
  return(out = list(I_x = mean(data$sq.diff), # average squared-error for x(s) estimates
                    I_x_v2 = mean(stations$DS_score), # average DS score
                    P_x = mean(data$absP.error), # average relative error for x(s)
                    ave_sd = mean(data$pred.SD), # average posterior uncertainty
                    pred.x = data$pred.x,
                    pred.SD = data$pred.SD,
                    sq.diff.vec = data$sq.diff,
                    absP.error.vec = data$absP.error,
                    Cor = cor(data$xvar, preds_mean_BMA),
                    true.x = data$xvar))

}




########################################################################
# Perform a comparison of three approaches for one simulated data
########################################################################

One_sim_run_ortho_error <- function(sim_data = sim_data,
                                    max_iter = max_iter,
                                    tolerance = tolerance, 
                                    matching_priors = matching_priors){
  
  compile_I_x_monsonly <- vector("list", length = 3)
  compile_I_x_datafusion <- vector("list", length = 3)
  compile_I_x_regcalib <- vector("list", length = 3)
  
  compile_P_x_monsonly <- vector("list", length = 3)
  compile_P_x_datafusion <- vector("list", length = 3)
  compile_P_x_regcalib <- vector("list", length = 3)
  
  compile_Corr_x_monsonly <- vector("list", length = 3)
  compile_Corr_x_datafusion <- vector("list", length = 3)
  compile_Corr_x_regcalib <- vector("list", length = 3)
  
  compile_Time_monsonly <- vector("list", length = 3)
  compile_Time_datafusion <- vector("list", length = 3)
  compile_Time_regcalib <- vector("list", length = 3)
  
  compile_I_x_v2_monsonly <- vector("list", length = 3)
  compile_I_x_v2_datafusion <- vector("list", length = 3)
  compile_I_x_v2_regcalib <- vector("list", length = 3)
  
  compile_I_Ave_SD_monsonly <- vector("list", length = 3)
  compile_I_Ave_SD_datafusion <- vector("list", length = 3)
  compile_I_Ave_SD_regcalib <- vector("list", length = 3)
  
  compile_mlik_data1 <- vector("list", length = 6)
  compile_mlik_data2 <- vector("list", length = 6)
  compile_mlik_data3 <- vector("list", length = 6)
  
  compile_bmaweights_data1 <- vector("list", length = 6)
  compile_bmaweights_data2 <- vector("list", length = 6)
  compile_bmaweights_data3 <- vector("list", length = 6)
  
  index_model <- vector("list", length = 3)
  
  compile_paramestimates_monsonly <- vector("list", length = 3)
  compile_paramestimates_datafusion <- vector("list", length = 3)
  compile_paramestimates_regcalib <- vector("list", length = 3)
  
  sim_data_1 <- sim_data
  sim_data_2 <- sim_data
  sim_data_3 <- sim_data
  sim_data_1$monitors_data <- sim_data$monitors_data[[1]]
  sim_data_2$monitors_data <- sim_data$monitors_data[[2]]
  sim_data_3$monitors_data <- sim_data$monitors_data[[3]]

  # Fit the proposed data fusion model
  alpha_grid = c(0.8,0.9,1,1.1,1.2,1.3) # these are the alpha_1 values considered
  res_sim_data_1 <- lapply(1:6, function(i){
    Fit_Ortho_Error_v5(data = sim_data_1,
                       max_iter = max_iter,
                       tolerance = tolerance,
                       matching_priors = matching_priors,
                       a = alpha_grid[i])}
  )
  res_sim_data_2 <- lapply(1:6, function(i){
    Fit_Ortho_Error_v5(data = sim_data_2,
                       max_iter = max_iter,
                       tolerance = tolerance,
                       matching_priors = matching_priors,
                       a = alpha_grid[i])}
  )
  res_sim_data_3 <- lapply(1:6, function(i){
    Fit_Ortho_Error_v5(data = sim_data_3,
                       max_iter = max_iter,
                       tolerance = tolerance,
                       matching_priors = matching_priors,
                       a = alpha_grid[i])}
  )

  # Fit the stations-only model
  res_mons_only_1 <- Fit_Mons_only_v3(data = sim_data_1,
                                      max_iter = max_iter,
                                      tolerance = tolerance,
                                      matching_priors = matching_priors)
  res_mons_only_2 <- Fit_Mons_only_v3(data = sim_data_2,
                                      max_iter = max_iter,
                                      tolerance = tolerance,
                                      matching_priors = matching_priors)
  res_mons_only_3 <- Fit_Mons_only_v3(data = sim_data_3,
                                      max_iter = max_iter,
                                      tolerance = tolerance,
                                      matching_priors = matching_priors)
  
  # Fit the regression calibration model
  res_regcalib_1 <- Fit_Regcalib_only_v2(data = sim_data_1,
                                         max_iter = max_iter,
                                         tolerance = tolerance,
                                         matching_priors = matching_priors)
  res_regcalib_2 <- Fit_Regcalib_only_v2(data = sim_data_2,
                                         max_iter = max_iter,
                                         tolerance = tolerance,
                                         matching_priors = matching_priors)
  res_regcalib_3 <- Fit_Regcalib_only_v2(data = sim_data_3,
                                         max_iter = max_iter,
                                         tolerance = tolerance,
                                         matching_priors = matching_priors)
  
  
  # Compile the marginal log-likelihoods
  for(i in 1:6){
    compile_mlik_data1[[i]] <- res_sim_data_1[[i]]$fit_res$mlik[1,1]
  }
  mliks_method_data1 <- unlist(compile_mlik_data1)
  bma.w.method_data1 <- exp(mliks_method_data1 - max(mliks_method_data1))
  bma.w.method_data1 <- bma.w.method_data1/sum(bma.w.method_data1)
  for(i in 1:6){
    compile_mlik_data2[[i]] <- res_sim_data_2[[i]]$fit_res$mlik[1,1]
  }
  mliks_method_data2 <- unlist(compile_mlik_data2)
  bma.w.method_data2 <- exp(mliks_method_data2 - max(mliks_method_data2))
  bma.w.method_data2 <- bma.w.method_data2/sum(bma.w.method_data2)
  for(i in 1:6){
    compile_mlik_data3[[i]] <- res_sim_data_3[[i]]$fit_res$mlik[1,1]
  }  
  mliks_method_data3 <- unlist(compile_mlik_data3)
  bma.w.method_data3 <- exp(mliks_method_data3 - max(mliks_method_data3))
  bma.w.method_data3 <- bma.w.method_data3/sum(bma.w.method_data3)
  
  # Identify the model with the highest weight
  index_model[[1]] <- which(compile_mlik_data1 == max(unlist(compile_mlik_data1)))
  index_model[[2]] <- which(compile_mlik_data2 == max(unlist(compile_mlik_data2)))
  index_model[[3]] <- which(compile_mlik_data3 == max(unlist(compile_mlik_data3)))


  # Compute prediction scores for the stations-only model
  I_x_monsonly_1 = compute_I_x_v3(model = res_mons_only_1$fit_res,
                                  data = sim_data_1$px,
                                  stations = sim_data_1$monitors_data)
  I_x_monsonly_2 = compute_I_x_v3(model = res_mons_only_2$fit_res,
                                  data = sim_data_2$px,
                                  stations = sim_data_2$monitors_data)
  I_x_monsonly_3 = compute_I_x_v3(model = res_mons_only_3$fit_res,
                                  data = sim_data_3$px,
                                  stations = sim_data_3$monitors_data)

  # Compute prediction scores for the regression calibration model
  I_x_regcalib_1 = compute_I_x_regcalib(model = res_regcalib_1,
                                        data = sim_data_1$px,
                                        stations = sim_data_1$monitors_data)
  I_x_regcalib_2 = compute_I_x_regcalib(model = res_regcalib_2,
                                        data = sim_data_2$px,
                                        stations = sim_data_2$monitors_data)
  I_x_regcalib_3 = compute_I_x_regcalib(model = res_regcalib_3,
                                        data = sim_data_3$px,
                                        stations = sim_data_3$monitors_data)
                               
  # Compute prediction scores for the proposed data fusion model
  I_x_datafus_1 = compute_I_x_datafus(model_list = res_sim_data_1,
                                      weights = bma.w.method_data1,
                                      data = sim_data_1$px,
                                      stations = sim_data_1$monitors_data,
                                      ind_model = index_model[[1]])
  I_x_datafus_2 = compute_I_x_datafus(model_list = res_sim_data_2,
                                      weights = bma.w.method_data2,
                                      data = sim_data_2$px,
                                      stations = sim_data_2$monitors_data,
                                      ind_model = index_model[[2]])
  I_x_datafus_3 = compute_I_x_datafus(model_list = res_sim_data_3,
                                      weights = bma.w.method_data3,
                                      data = sim_data_3$px,
                                      stations = sim_data_3$monitors_data,
                                      ind_model = index_model[[3]])
  
  # Compile the average squared-errors for estimated x(s) for stations-only model
  compile_I_x_monsonly[[1]] <- I_x_monsonly_1$I_x
  compile_I_x_monsonly[[2]] <- I_x_monsonly_2$I_x
  compile_I_x_monsonly[[3]] <- I_x_monsonly_3$I_x
  # Compile the average squared-errors for estimated x(s) for regression calibration model
  compile_I_x_regcalib[[1]] <- I_x_regcalib_1$I_x
  compile_I_x_regcalib[[2]] <- I_x_regcalib_2$I_x
  compile_I_x_regcalib[[3]] <- I_x_regcalib_3$I_x
  # Compile the average squared-errors for estimated x(s) for the proposed data fusion model
  compile_I_x_datafusion[[1]] <- I_x_datafus_1$I_x
  compile_I_x_datafusion[[2]] <- I_x_datafus_2$I_x
  compile_I_x_datafusion[[3]] <- I_x_datafus_3$I_x

  # Compile the average DS scores for w_1(s) for stations-only model
  compile_I_x_v2_monsonly[[1]] <- I_x_monsonly_1$I_x_v2
  compile_I_x_v2_monsonly[[2]] <- I_x_monsonly_2$I_x_v2
  compile_I_x_v2_monsonly[[3]] <- I_x_monsonly_3$I_x_v2
  # Compile the average DS scores for w_1(s) for regression calibration model
  compile_I_x_v2_regcalib[[1]] <- I_x_regcalib_1$I_x_v2
  compile_I_x_v2_regcalib[[2]] <- I_x_regcalib_2$I_x_v2
  compile_I_x_v2_regcalib[[3]] <- I_x_regcalib_3$I_x_v2
  # Compile the average DS scores for w_1(s) for proposed data fusion model
  compile_I_x_v2_datafusion[[1]] <- I_x_datafus_1$I_x_v2
  compile_I_x_v2_datafusion[[2]] <- I_x_datafus_2$I_x_v2
  compile_I_x_v2_datafusion[[3]] <- I_x_datafus_3$I_x_v2

  # Compile the average posterior SD of estimated x(s) for stations-only model
  compile_I_Ave_SD_monsonly[[1]] <- I_x_monsonly_1$ave_sd
  compile_I_Ave_SD_monsonly[[2]] <- I_x_monsonly_2$ave_sd
  compile_I_Ave_SD_monsonly[[3]] <- I_x_monsonly_3$ave_sd
  # Compile the average posterior SD of estimated x(s) for regression calibration model
  compile_I_Ave_SD_regcalib[[1]] <- I_x_regcalib_1$ave_sd
  compile_I_Ave_SD_regcalib[[2]] <- I_x_regcalib_2$ave_sd
  compile_I_Ave_SD_regcalib[[3]] <- I_x_regcalib_3$ave_sd
  # Compile the average posterior SD of estimated x(s) for proposed data fusion model
  compile_I_Ave_SD_datafusion[[1]] <- I_x_datafus_1$ave_sd
  compile_I_Ave_SD_datafusion[[2]] <- I_x_datafus_2$ave_sd
  compile_I_Ave_SD_datafusion[[3]] <- I_x_datafus_3$ave_sd
  
  # Compile the relative error of estimated x(s) for stations-only model
  compile_P_x_monsonly[[1]] <- I_x_monsonly_1$P_x
  compile_P_x_monsonly[[2]] <- I_x_monsonly_2$P_x
  compile_P_x_monsonly[[3]] <- I_x_monsonly_3$P_x
  # Compile the relative error of estimated x(s) for regression calibration model
  compile_P_x_regcalib[[1]] <- I_x_regcalib_1$P_x
  compile_P_x_regcalib[[2]] <- I_x_regcalib_2$P_x
  compile_P_x_regcalib[[3]] <- I_x_regcalib_3$P_x
  # Compile the relative error of estimated x(s) for proposed data fusion model
  compile_P_x_datafusion[[1]] <- I_x_datafus_1$P_x
  compile_P_x_datafusion[[2]] <- I_x_datafus_2$P_x
  compile_P_x_datafusion[[3]] <- I_x_datafus_3$P_x
  
  # Compile the correlation between x(s) and estimated x(s) for stations-only model
  compile_Corr_x_monsonly[[1]] <- I_x_monsonly_1$Cor
  compile_Corr_x_monsonly[[2]] <- I_x_monsonly_2$Cor
  compile_Corr_x_monsonly[[3]] <- I_x_monsonly_3$Cor
  # Compile the correlation between x(s) and estimated x(s) for regression calibration model
  compile_Corr_x_regcalib[[1]] <- I_x_regcalib_1$Cor
  compile_Corr_x_regcalib[[2]] <- I_x_regcalib_2$Cor
  compile_Corr_x_regcalib[[3]] <- I_x_regcalib_3$Cor
  # Compile the correlation between x(s) and estimated x(s) for proposed data fusion model
  compile_Corr_x_datafusion[[1]] <- I_x_datafus_1$Cor
  compile_Corr_x_datafusion[[2]] <- I_x_datafus_2$Cor
  compile_Corr_x_datafusion[[3]] <- I_x_datafus_3$Cor

  # Compile the posterior estimates for the stations-only model
  for(i in 1:3){
    res_temp <- get(paste0("res_mons_only_",i))
    compile_paramestimates_monsonly[[i]] <- list(inla.rmarginal(200, res_temp$fit_res$marginals.fixed$beta_0),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.fixed$beta_1),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Range for spde`),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Stdev for spde`),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`))
  }

  # Compile the posterior estimates for the regression calibration model
  for(i in 1:3){
    res_temp <- get(paste0("res_regcalib_",i))
    compile_paramestimates_regcalib[[i]] <- list(inla.rmarginal(200, res_temp$fit_res$marginals.fixed$beta_0),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.fixed$beta_1),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Range for spde`),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Stdev for spde`),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`),
                                                 inla.rmarginal(200, res_temp$fit_res$marginals.fixed$beta_2))
                                        
  }
  
  # Compile the posterior estimates for the proposed data fusion model conditional on the alpha_1 with the highest weight
  for(i in 1:3){
    res_temp <- get(paste0("res_sim_data_",i))
    res_temp <- res_temp[[index_model[[i]]]]
    compile_paramestimates_datafusion[[i]] <- list(inla.rmarginal(200, res_temp$fit_res$marginals.fixed$beta_0),
                                                   inla.rmarginal(200, res_temp$fit_res$marginals.fixed$beta_1),
                                                   inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Range for spde`),
                                                   inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Stdev for spde`),
                                                   inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`),
                                                   inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Range for matern_error`),
                                                   inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Stdev for matern_error`),
                                                   inla.rmarginal(200, res_temp$fit_res$marginals.hyperpar$`Precision for the Gaussian observations[2]`))
  }
  
  # Compile the posterior estimates for the proposed data fusion model conditional on all alpha_1 values 
  compile_paramestimates_datafusion_temp <- vector(mode = "list", length = 3)
  for(i in 1:3){
    res_temp <- get(paste0("res_sim_data_",i))
    for(j in 1:6){
      res_temp2 <- res_temp[[j]]
      compile_paramestimates_datafusion_temp[[i]][[j]] <- list(inla.rmarginal(200, res_temp2$fit_res$marginals.fixed$beta_0),
                                                               inla.rmarginal(200, res_temp2$fit_res$marginals.fixed$beta_1),
                                                               inla.rmarginal(200, res_temp2$fit_res$marginals.hyperpar$`Range for spde`),
                                                               inla.rmarginal(200, res_temp2$fit_res$marginals.hyperpar$`Stdev for spde`),
                                                               inla.rmarginal(200, res_temp2$fit_res$marginals.hyperpar$`Precision for the Gaussian observations`),
                                                               inla.rmarginal(200, res_temp2$fit_res$marginals.hyperpar$`Range for matern_error`),
                                                               inla.rmarginal(200, res_temp2$fit_res$marginals.hyperpar$`Stdev for matern_error`),
                                                               inla.rmarginal(200, res_temp2$fit_res$marginals.hyperpar$`Precision for the Gaussian observations[2]`))
    }
  }

  # Compile the model-averaged posterior estimates for the proposed data fusion model
  for(i in 1:3){
    temp <- compile_paramestimates_datafusion_temp[[i]]
    weights <- get(paste0("bma.w.method_data",i))
    for(j in 1:7){
      compile_paramestimates_datafusion[[i]][[j]] <- temp[[1]][[j]]*weights[1] + temp[[2]][[j]]*weights[2] + temp[[3]][[j]]*weights[3] + 
        temp[[4]][[j]]*weights[4] + temp[[5]][[j]]*weights[5] + temp[[6]][[j]]*weights[6]
      
    }
  }

  
  return(out = list(compile_I_x_monsonly = compile_I_x_monsonly,
                    compile_I_x_regcalib = compile_I_x_regcalib,
                    compile_I_x_datafusion = compile_I_x_datafusion,
                    compile_P_x_monsonly = compile_P_x_monsonly,
                    compile_P_x_regcalib = compile_P_x_regcalib,
                    compile_P_x_datafusion = compile_P_x_datafusion,
                    compile_Corr_x_monsonly = compile_Corr_x_monsonly,
                    compile_Corr_x_regcalib = compile_Corr_x_regcalib,
                    compile_Corr_x_datafusion = compile_Corr_x_datafusion,
                    compile_paramestimates_monsonly = compile_paramestimates_monsonly,
                    compile_paramestimates_regcalib = compile_paramestimates_regcalib,
                    compile_paramestimates_datafusion = compile_paramestimates_datafusion,
                    compile_mlik_data1 = compile_mlik_data1,
                    compile_mlik_data2 = compile_mlik_data2,
                    compile_mlik_data3 = compile_mlik_data3,
                    index_model = index_model,
                    compile_I_x_v2_monsonly = compile_I_x_v2_monsonly,
                    compile_I_x_v2_regcalib = compile_I_x_v2_regcalib,
                    compile_I_x_v2_datafusion = compile_I_x_v2_datafusion,
                    compile_I_Ave_SD_monsonly = compile_I_Ave_SD_monsonly,
                    compile_I_Ave_SD_regcalib = compile_I_Ave_SD_regcalib,
                    compile_I_Ave_SD_datafusion = compile_I_Ave_SD_datafusion,
                    compile_bmaweights_data1 = bma.w.method_data1,
                    compile_bmaweights_data2 = bma.w.method_data2,
                    compile_bmaweights_data3 = bma.w.method_data3))
  
}




Full_sim_ortho_error <- function(n_sim = n_sim,
                                 max_iter = max_iter,
                                 tolerance = tolerance){

  # Compile posterior predictions scores and posterior estimates for model with MATCHING priors
  # The "_info" in the object names doesn't truly mean "informative priors", but the use of matching priors
  compile_I_x_monsonly_info <- vector("list", length = 3)
  compile_I_x_regcalib_info <- vector("list", length = 3)
  compile_I_x_datafusion_info <- vector("list", length = 3)
  compile_I_x_v2_monsonly_info <- vector("list", length = 3)
  compile_I_x_v2_regcalib_info <- vector("list", length = 3)
  compile_I_x_v2_datafusion_info <- vector("list", length = 3)
  compile_Ave_SD_monsonly_info <- vector("list", length = 3)
  compile_Ave_SD_regcalib_info <- vector("list", length = 3)
  compile_Ave_SD_datafus_info <- vector("list", length = 3)
  compile_P_x_monsonly_info <- vector("list", length = 3)
  compile_P_x_regcalib_info <- vector("list", length = 3)
  compile_P_x_datafusion_info <- vector("list", length = 3)
  compile_Corr_x_monsonly_info <- vector("list", length = 3)
  compile_Corr_x_regcalib_info <- vector("list", length = 3)
  compile_Corr_x_datafusion_info <- vector("list", length = 3)
  compile_paramestimates_datafusion_info <- vector("list", length = 3)
  compile_paramestimates_regcalib_info <- vector("list", length = 3)
  compile_paramestimates_monsonly_info <- vector("list", length = 3)  
  for(i in 1:3){
    compile_paramestimates_datafusion_info[[i]] <- vector("list", length = 8)
    compile_paramestimates_regcalib_info[[i]] <- vector("list", length = 6)
    compile_paramestimates_monsonly_info[[i]] <- vector("list", length = 5)
  }

  # Compile posterior predictions scores and posterior estimates for model with NON-MATCHING priors
  # The "_noninfo" in the object names doesn't truly mean "noninformative priors", but the use of non-matching priors
  compile_I_x_monsonly_noninfo <- vector("list", length = 3)
  compile_I_x_regcalib_noninfo <- vector("list", length = 3)
  compile_I_x_datafusion_noninfo <- vector("list", length = 3)
  compile_I_x_v2_monsonly_noninfo <- vector("list", length = 3)
  compile_I_x_v2_regcalib_noninfo <- vector("list", length = 3)
  compile_I_x_v2_datafusion_noninfo <- vector("list", length = 3)
  compile_Ave_SD_monsonly_noninfo <- vector("list", length = 3)
  compile_Ave_SD_regcalib_noninfo <- vector("list", length = 3)
  compile_Ave_SD_datafus_noninfo <- vector("list", length = 3)
  compile_P_x_monsonly_noninfo <- vector("list", length = 3)
  compile_P_x_regcalib_noninfo <- vector("list", length = 3)
  compile_P_x_datafusion_noninfo <- vector("list", length = 3)
  compile_Corr_x_monsonly_noninfo <- vector("list", length = 3)
  compile_Corr_x_regcalib_noninfo <- vector("list", length = 3)
  compile_Corr_x_datafusion_noninfo <- vector("list", length = 3)
  compile_paramestimates_datafusion_noninfo <- vector("list", length = 3)
  compile_paramestimates_regcalib_noninfo <- vector("list", length = 3)
  compile_paramestimates_monsonly_noninfo <- vector("list", length = 3)
  for(i in 1:3){
    compile_paramestimates_datafusion_noninfo[[i]] <- vector("list", length = 8)
    compile_paramestimates_regcalib_noninfo[[i]] <- vector("list", length = 6)
    compile_paramestimates_monsonly_noninfo[[i]] <- vector("list", length = 5)
  }

  # Compile all marginal log-likelihoods
  compile_mlik_data1_info <- vector("list", length = 6)
  compile_mlik_data2_info <- vector("list", length = 6)
  compile_mlik_data3_info <- vector("list", length = 6)
  compile_mlik_data1_noninfo <- vector("list", length = 6)
  compile_mlik_data2_noninfo <- vector("list", length = 6)
  compile_mlik_data3_noninfo <- vector("list", length = 6)

  # Compile the index for conditional INLA model (proposed method) with highest weight
  compile_index_model_info <- vector("list", length = 3)
  compile_index_model_noninfo <- vector("list", length = 3)

  # Compile all BMA weights
  compile_weights_data1_info <- vector("list", length = 6)
  compile_weights_data2_info <- vector("list", length = 6)
  compile_weights_data3_info <- vector("list", length = 6)
  compile_weights_data1_noninfo <- vector("list", length = 6)
  compile_weights_data2_noninfo <- vector("list", length = 6)
  compile_weights_data3_noninfo <- vector("list", length = 6)
  
  for(n in 1:n_sim){
    
    sim_data <- Sim_Data_Ortho_error_v3()
    one_sim_informative <- One_sim_run_ortho_error(sim_data = sim_data,
                                                   max_iter = max_iter,
                                                   tolerance = tolerance,
                                                   matching_priors = TRUE)
    one_sim_noninformative <- One_sim_run_ortho_error(sim_data = sim_data,
                                                      max_iter = max_iter,
                                                      tolerance = tolerance,
                                                      matching_priors = FALSE)
    
    cat("Sim = ", n," out of ",n_sim, sep="","\n" )
    
    for(i in 1:3){
      
      # results for matching priors
      
      compile_I_x_monsonly_info[[i]] <- c(compile_I_x_monsonly_info[[i]], one_sim_informative$compile_I_x_monsonly[[i]])
      compile_I_x_regcalib_info[[i]] <- c(compile_I_x_regcalib_info[[i]], one_sim_informative$compile_I_x_regcalib[[i]])
      compile_I_x_datafusion_info[[i]] <- c(compile_I_x_datafusion_info[[i]], one_sim_informative$compile_I_x_datafusion[[i]])
      
      compile_I_x_v2_monsonly_info[[i]] <- c(compile_I_x_v2_monsonly_info[[i]], one_sim_informative$compile_I_x_v2_monsonly[[i]])
      compile_I_x_v2_regcalib_info[[i]] <- c(compile_I_x_v2_regcalib_info[[i]], one_sim_informative$compile_I_x_v2_regcalib[[i]])
      compile_I_x_v2_datafusion_info[[i]] <- c(compile_I_x_v2_datafusion_info[[i]], one_sim_informative$compile_I_x_v2_datafusion[[i]])
      
      compile_Ave_SD_monsonly_info[[i]] <- c(compile_Ave_SD_monsonly_info[[i]], one_sim_informative$compile_I_Ave_SD_monsonly[[i]])
      compile_Ave_SD_regcalib_info[[i]] <- c(compile_Ave_SD_regcalib_info[[i]], one_sim_informative$compile_I_Ave_SD_regcalib[[i]])
      compile_Ave_SD_datafus_info[[i]] <- c(compile_Ave_SD_datafus_info[[i]], one_sim_informative$compile_I_Ave_SD_datafusion[[i]])
      
      compile_P_x_monsonly_info[[i]] <- c(compile_P_x_monsonly_info[[i]], one_sim_informative$compile_P_x_monsonly[[i]])
      compile_P_x_regcalib_info[[i]] <- c(compile_P_x_regcalib_info[[i]], one_sim_informative$compile_P_x_regcalib[[i]])
      compile_P_x_datafusion_info[[i]] <- c(compile_P_x_datafusion_info[[i]], one_sim_informative$compile_P_x_datafusion[[i]])
      
      compile_Corr_x_monsonly_info[[i]] <- c(compile_Corr_x_monsonly_info[[i]], one_sim_informative$compile_Corr_x_monsonly[[i]])
      compile_Corr_x_regcalib_info[[i]] <- c(compile_Corr_x_regcalib_info[[i]], one_sim_informative$compile_Corr_x_regcalib[[i]])
      compile_Corr_x_datafusion_info[[i]] <- c(compile_Corr_x_datafusion_info[[i]], one_sim_informative$compile_Corr_x_datafusion[[i]])
      
      # results for non-matching priors
      
      compile_I_x_monsonly_noninfo[[i]] <- c(compile_I_x_monsonly_noninfo[[i]], one_sim_noninformative$compile_I_x_monsonly[[i]])
      compile_I_x_regcalib_noninfo[[i]] <- c(compile_I_x_regcalib_noninfo[[i]], one_sim_noninformative$compile_I_x_regcalib[[i]])
      compile_I_x_datafusion_noninfo[[i]] <- c(compile_I_x_datafusion_noninfo[[i]], one_sim_noninformative$compile_I_x_datafusion[[i]])
      
      compile_I_x_v2_monsonly_noninfo[[i]] <- c(compile_I_x_v2_monsonly_noninfo[[i]], one_sim_noninformative$compile_I_x_v2_monsonly[[i]])
      compile_I_x_v2_regcalib_noninfo[[i]] <- c(compile_I_x_v2_regcalib_noninfo[[i]], one_sim_noninformative$compile_I_x_v2_regcalib[[i]])
      compile_I_x_v2_datafusion_noninfo[[i]] <- c(compile_I_x_v2_datafusion_noninfo[[i]], one_sim_noninformative$compile_I_x_v2_datafusion[[i]])
      
      compile_Ave_SD_monsonly_noninfo[[i]] <- c(compile_Ave_SD_monsonly_noninfo[[i]], one_sim_noninformative$compile_I_Ave_SD_monsonly[[i]])
      compile_Ave_SD_regcalib_noninfo[[i]] <- c(compile_Ave_SD_regcalib_noninfo[[i]], one_sim_noninformative$compile_I_Ave_SD_regcalib[[i]])
      compile_Ave_SD_datafus_noninfo[[i]] <- c(compile_Ave_SD_datafus_noninfo[[i]], one_sim_noninformative$compile_I_Ave_SD_datafusion[[i]])
      
      compile_P_x_monsonly_noninfo[[i]] <- c(compile_P_x_monsonly_noninfo[[i]], one_sim_noninformative$compile_P_x_monsonly[[i]])
      compile_P_x_regcalib_noninfo[[i]] <- c(compile_P_x_regcalib_noninfo[[i]], one_sim_noninformative$compile_P_x_regcalib[[i]])
      compile_P_x_datafusion_noninfo[[i]] <- c(compile_P_x_datafusion_noninfo[[i]], one_sim_noninformative$compile_P_x_datafusion[[i]])
      
      compile_Corr_x_monsonly_noninfo[[i]] <- c(compile_Corr_x_monsonly_noninfo[[i]], one_sim_noninformative$compile_Corr_x_monsonly[[i]])
      compile_Corr_x_regcalib_noninfo[[i]] <- c(compile_Corr_x_regcalib_noninfo[[i]], one_sim_noninformative$compile_Corr_x_regcalib[[i]])
      compile_Corr_x_datafusion_noninfo[[i]] <- c(compile_Corr_x_datafusion_noninfo[[i]], one_sim_noninformative$compile_Corr_x_datafusion[[i]])
      
      compile_index_model_info[[i]] <- c(compile_index_model_info[[i]], one_sim_informative$index_model[[i]])
      compile_index_model_info[[i]] <- c(compile_index_model_info[[i]], one_sim_informative$index_model[[i]])
      compile_index_model_noninfo[[i]] <- c(compile_index_model_noninfo[[i]], one_sim_noninformative$index_model[[i]])
      
    }  

    # Compile all marginal log-likelihoods and BMA weights
    for(i in 1:6){
      compile_mlik_data1_info[[i]] <- c(compile_mlik_data1_info[[i]], one_sim_informative$compile_mlik_data1[[i]])
      compile_mlik_data2_info[[i]] <- c(compile_mlik_data2_info[[i]], one_sim_informative$compile_mlik_data2[[i]])
      compile_mlik_data3_info[[i]] <- c(compile_mlik_data3_info[[i]], one_sim_informative$compile_mlik_data3[[i]])
      
      compile_mlik_data1_noninfo[[i]] <- c(compile_mlik_data1_noninfo[[i]], one_sim_noninformative$compile_mlik_data1[[i]])
      compile_mlik_data2_noninfo[[i]] <- c(compile_mlik_data2_noninfo[[i]], one_sim_noninformative$compile_mlik_data2[[i]])
      compile_mlik_data3_noninfo[[i]] <- c(compile_mlik_data3_noninfo[[i]], one_sim_noninformative$compile_mlik_data3[[i]])
      
      compile_weights_data1_info[[i]] <- c(compile_weights_data1_info[[i]], one_sim_informative$compile_bmaweights_data1[[i]])
      compile_weights_data2_info[[i]] <- c(compile_weights_data2_info[[i]], one_sim_informative$compile_bmaweights_data2[[i]])
      compile_weights_data3_info[[i]] <- c(compile_weights_data3_info[[i]], one_sim_informative$compile_bmaweights_data3[[i]])
      
      compile_weights_data1_noninfo[[i]] <- c(compile_weights_data1_noninfo[[i]], one_sim_noninformative$compile_bmaweights_data1[[i]])
      compile_weights_data2_noninfo[[i]] <- c(compile_weights_data2_noninfo[[i]], one_sim_noninformative$compile_bmaweights_data2[[i]])
      compile_weights_data3_noninfo[[i]] <- c(compile_weights_data3_noninfo[[i]], one_sim_noninformative$compile_bmaweights_data3[[i]])     
    }

    # Compile all posterior estimates 
    for(i in 1:3){
      # Model-averaged posterior estimates for the proposed data fusion model
      for(j in 1:8){
        compile_paramestimates_datafusion_info[[i]][[j]] <- c(compile_paramestimates_datafusion_info[[i]][[j]],
                                                              one_sim_informative$compile_paramestimates_datafusion[[i]][[j]])
        compile_paramestimates_datafusion_noninfo[[i]][[j]] <- c(compile_paramestimates_datafusion_noninfo[[i]][[j]],
                                                                 one_sim_noninformative$compile_paramestimates_datafusion[[i]][[j]])
      }
      # Posterior estimates for the stations-only model
      for(j in 1:5){
        compile_paramestimates_monsonly_info[[i]][[j]] <- c(compile_paramestimates_monsonly_info[[i]][[j]],
                                                            one_sim_informative$compile_paramestimates_monsonly[[i]][[j]])
        compile_paramestimates_monsonly_noninfo[[i]][[j]] <- c(compile_paramestimates_monsonly_noninfo[[i]][[j]],
                                                               one_sim_noninformative$compile_paramestimates_monsonly[[i]][[j]])
      }
      # Posterior estimates for the regression calibration model
      for(j in 1:6){
        compile_paramestimates_regcalib_info[[i]][[j]] <- c(compile_paramestimates_regcalib_info[[i]][[j]],
                                                          one_sim_informative$compile_paramestimates_regcalib[[i]][[j]])
        compile_paramestimates_regcalib_noninfo[[i]][[j]] <- c(compile_paramestimates_regcalib_noninfo[[i]][[j]],
                                                             one_sim_noninformative$compile_paramestimates_regcalib[[i]][[j]])
    }
  }
  
  }
  
  return(out = list(compile_I_x_monsonly_info = compile_I_x_monsonly_info,
                    compile_I_x_regcalib_info = compile_I_x_regcalib_info,
                    compile_I_x_datafusion_info = compile_I_x_datafusion_info,

                    compile_I_x_v2_monsonly_info = compile_I_x_v2_monsonly_info,
                    compile_I_x_v2_regcalib_info = compile_I_x_v2_regcalib_info,
                    compile_I_x_v2_datafusion_info = compile_I_x_v2_datafusion_info,
                    
                    compile_Ave_SD_monsonly_info = compile_Ave_SD_monsonly_info,
                    compile_Ave_SD_regcalib_info = compile_Ave_SD_regcalib_info,
                    compile_Ave_SD_datafus_info = compile_Ave_SD_datafus_info,
                    
                    compile_P_x_monsonly_info = compile_P_x_monsonly_info,
                    compile_P_x_regcalib_info = compile_P_x_regcalib_info,
                    compile_P_x_datafusion_info = compile_P_x_datafusion_info,
                    
                    compile_Corr_x_monsonly_info = compile_Corr_x_monsonly_info,
                    compile_Corr_x_regcalib_info = compile_Corr_x_regcalib_info,
                    compile_Corr_x_datafusion_info = compile_Corr_x_datafusion_info,
                  
                    compile_I_x_monsonly_noninfo = compile_I_x_monsonly_noninfo,
                    compile_I_x_regcalib_noninfo = compile_I_x_regcalib_noninfo,
                    compile_I_x_datafusion_noninfo = compile_I_x_datafusion_noninfo,
                    
                    compile_I_x_v2_monsonly_noninfo = compile_I_x_v2_monsonly_noninfo,
                    compile_I_x_v2_regcalib_noninfo = compile_I_x_v2_regcalib_noninfo,
                    compile_I_x_v2_datafusion_noninfo = compile_I_x_v2_datafusion_noninfo,
                    
                    compile_Ave_SD_monsonly_noninfo = compile_Ave_SD_monsonly_noninfo,
                    compile_Ave_SD_regcalib_noninfo = compile_Ave_SD_regcalib_noninfo,
                    compile_Ave_SD_datafus_noninfo = compile_Ave_SD_datafus_noninfo,
                    
                    compile_P_x_monsonly_noninfo = compile_P_x_monsonly_noninfo,
                    compile_P_x_regcalib_noninfo = compile_P_x_regcalib_noninfo,
                    compile_P_x_datafusion_noninfo = compile_P_x_datafusion_noninfo,
                    
                    compile_Corr_x_monsonly_noninfo = compile_Corr_x_monsonly_noninfo,
                    compile_Corr_x_regcalib_noninfo = compile_Corr_x_regcalib_noninfo,
                    compile_Corr_x_datafusion_noninfo = compile_Corr_x_datafusion_noninfo,
                    
                    compile_paramestimates_datafusion_info = compile_paramestimates_datafusion_info,
                    compile_paramestimates_datafusion_noninfo = compile_paramestimates_datafusion_noninfo,
                    compile_paramestimates_regcalib_info = compile_paramestimates_regcalib_info,
                    compile_paramestimates_regcalib_noninfo = compile_paramestimates_regcalib_noninfo,
                    compile_paramestimates_monsonly_info = compile_paramestimates_monsonly_info,
                    compile_paramestimates_monsonly_noninfo = compile_paramestimates_monsonly_noninfo,
                    
                    compile_mlik_data1_info = compile_mlik_data1_info,
                    compile_mlik_data2_info = compile_mlik_data2_info,
                    compile_mlik_data3_info = compile_mlik_data3_info,
                    compile_mlik_data1_noninfo = compile_mlik_data1_noninfo,
                    compile_mlik_data2_noninfo = compile_mlik_data2_noninfo,
                    compile_mlik_data3_noninfo = compile_mlik_data3_noninfo,
                    compile_weights_data1_info = compile_weights_data1_info,
                    compile_weights_data2_info = compile_weights_data2_info,
                    compile_weights_data3_info = compile_weights_data3_info,
                    compile_weights_data1_noninfo = compile_weights_data1_noninfo,
                    compile_weights_data2_noninfo = compile_weights_data2_noninfo,
                    compile_weights_data3_noninfo = compile_weights_data3_noninfo,
                    compile_index_model_info = compile_index_model_info,
                    compile_index_model_noninfo = compile_index_model_noninfo))
  
}



